<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RenderingThing Docs - Vertex</title>
  <link rel="stylesheet" href="../style.css" />
</head>
<body data-page="ref-vertex">
  <header class="topbar">
    <div class="brand">
      <div class="logo">RT</div>
      <div>RenderingThing Docs</div>
      <span class="badge">Local</span>
    </div>
    <div class="search">
      <input type="search" placeholder="Search docs (local)" />
    </div>
    <button class="nav-toggle" aria-label="Toggle navigation">Menu</button>
  </header>

  <div class="layout">
    <nav class="sidenav">

      <h3>Documentation</h3>
      <ul>
        <li><a href="../index.html" data-page-link="overview">Overview</a></li>
        <li><a href="../getting-started.html" data-page-link="getting-started">Getting Started</a></li>
        <li><a href="../samples.html" data-page-link="samples">Samples</a></li>
        <li><a href="../architecture.html" data-page-link="architecture">Architecture</a></li>
        <li><a href="../graphics.html" data-page-link="graphics">Graphics</a></li>
        <li><a href="index.html" data-page-link="reference">Reference</a></li>
      </ul>
      <h3>Reference</h3>
      <ul>
<li><a href="asset.html" data-page-link="ref-asset">Asset</a></li>
<li><a href="assetmanager.html" data-page-link="ref-assetmanager">AssetManager</a></li>
<li><a href="bufferedimage.html" data-page-link="ref-bufferedimage">BufferedImage</a></li>
<li><a href="camera.html" data-page-link="ref-camera">Camera</a></li>
<li><a href="camerasettings.html" data-page-link="ref-camerasettings">CameraSettings</a></li>
<li><a href="color.html" data-page-link="ref-color">Color</a></li>
<li><a href="colormaterial.html" data-page-link="ref-colormaterial">ColorMaterial</a></li>
<li><a href="cubemap.html" data-page-link="ref-cubemap">CubeMap</a></li>
<li><a href="cubemapslot.html" data-page-link="ref-cubemapslot">CubeMapSlot</a></li>
<li><a href="cubematerialdefinition.html" data-page-link="ref-cubematerialdefinition">CubeMaterialDefinition</a></li>
<li><a href="depthguard.html" data-page-link="ref-depthguard">DepthGuard</a></li>
<li><a href="display.html" data-page-link="ref-display">Display</a></li>
<li><a href="displaymode.html" data-page-link="ref-displaymode">DisplayMode</a></li>
<li><a href="file.html" data-page-link="ref-file">File</a></li>
<li><a href="fileblob.html" data-page-link="ref-fileblob">FileBlob</a></li>
<li><a href="filereader.html" data-page-link="ref-filereader">FileReader</a></li>
<li><a href="filewriter.html" data-page-link="ref-filewriter">FileWriter</a></li>
<li><a href="firstpersoncontroller.html" data-page-link="ref-firstpersoncontroller">FirstPersonController</a></li>
<li><a href="flatcolormaterial.html" data-page-link="ref-flatcolormaterial">FlatColorMaterial</a></li>
<li><a href="flatimagematerial.html" data-page-link="ref-flatimagematerial">FlatImageMaterial</a></li>
<li><a href="font.html" data-page-link="ref-font">Font</a></li>
<li><a href="fontcharacter.html" data-page-link="ref-fontcharacter">FontCharacter</a></li>
<li><a href="framebuffer.html" data-page-link="ref-framebuffer">FrameBuffer</a></li>
<li><a href="framebufferchain.html" data-page-link="ref-framebufferchain">FrameBufferChain</a></li>
<li><a href="freetypefont.html" data-page-link="ref-freetypefont">FreeTypeFont</a></li>
<li><a href="glversioninfo.html" data-page-link="ref-glversioninfo">GLVersionInfo</a></li>
<li><a href="graphics2d.html" data-page-link="ref-graphics2d">Graphics2D</a></li>
<li><a href="graphicscontext.html" data-page-link="ref-graphicscontext">GraphicsContext</a></li>
<li><a href="grayscaleeffect.html" data-page-link="ref-grayscaleeffect">GrayscaleEffect</a></li>
<li><a href="idrawable.html" data-page-link="ref-idrawable">IDrawable</a></li>
<li><a href="ieventhandler.html" data-page-link="ref-ieventhandler">IEventHandler</a></li>
<li><a href="image.html" data-page-link="ref-image">Image</a></li>
<li><a href="imagematerial.html" data-page-link="ref-imagematerial">ImageMaterial</a></li>
<li><a href="imaterialproperty.html" data-page-link="ref-imaterialproperty">IMaterialProperty</a></li>
<li><a href="inputinformation.html" data-page-link="ref-inputinformation">InputInformation</a></li>
<li><a href="inputmanager.html" data-page-link="ref-inputmanager">InputManager</a></li>
<li><a href="light.html" data-page-link="ref-light">Light</a></li>
<li><a href="lightmanager.html" data-page-link="ref-lightmanager">LightManager</a></li>
<li><a href="lighttype.html" data-page-link="ref-lighttype">LightType</a></li>
<li><a href="lightuniformuploader.html" data-page-link="ref-lightuniformuploader">LightUniformUploader</a></li>
<li><a href="lineending.html" data-page-link="ref-lineending">LineEnding</a></li>
<li><a href="litcolormaterial.html" data-page-link="ref-litcolormaterial">LitColorMaterial</a></li>
<li><a href="litimagematerial.html" data-page-link="ref-litimagematerial">LitImageMaterial</a></li>
<li><a href="logbot.html" data-page-link="ref-logbot">Logbot</a></li>
<li><a href="logtype.html" data-page-link="ref-logtype">LogType</a></li>
<li><a href="mat4.html" data-page-link="ref-mat4">Mat4</a></li>
<li><a href="material.html" data-page-link="ref-material">Material</a></li>
<li><a href="materialproperty.html" data-page-link="ref-materialproperty">MaterialProperty</a></li>
<li><a href="mesh.html" data-page-link="ref-mesh">Mesh</a></li>
<li><a href="model.html" data-page-link="ref-model">Model</a></li>
<li><a href="modelpart.html" data-page-link="ref-modelpart">ModelPart</a></li>
<li><a href="modelpartfactory.html" data-page-link="ref-modelpartfactory">ModelPartFactory</a></li>
<li><a href="modelpartprefabs.html" data-page-link="ref-modelpartprefabs">ModelPartPrefabs</a></li>
<li><a href="modelprefabs.html" data-page-link="ref-modelprefabs">ModelPrefabs</a></li>
<li><a href="mouselockmode.html" data-page-link="ref-mouselockmode">MouseLockMode</a></li>
<li><a href="nullable.html" data-page-link="ref-nullable">Nullable</a></li>
<li><a href="objdata.html" data-page-link="ref-objdata">OBJData</a></li>
<li><a href="objloader.html" data-page-link="ref-objloader">OBJLoader</a></li>
<li><a href="pbrmaterial.html" data-page-link="ref-pbrmaterial">PBRMaterial</a></li>
<li><a href="postprocessingeffect.html" data-page-link="ref-postprocessingeffect">PostProcessingEffect</a></li>
<li><a href="quat.html" data-page-link="ref-quat">Quat</a></li>
<li><a href="random.html" data-page-link="ref-random">Random</a></li>
<li><a href="rect.html" data-page-link="ref-rect">Rect</a></li>
<li><a href="renderwindow.html" data-page-link="ref-renderwindow">RenderWindow</a></li>
<li><a href="screen.html" data-page-link="ref-screen">Screen</a></li>
<li><a href="shaderbundle.html" data-page-link="ref-shaderbundle">ShaderBundle</a></li>
<li><a href="shadercache.html" data-page-link="ref-shadercache">ShaderCache</a></li>
<li><a href="shaderprogram.html" data-page-link="ref-shaderprogram">ShaderProgram</a></li>
<li><a href="shadowlightdata.html" data-page-link="ref-shadowlightdata">ShadowLightData</a></li>
<li><a href="shadowmap2d.html" data-page-link="ref-shadowmap2d">ShadowMap2D</a></li>
<li><a href="shadowmapcube.html" data-page-link="ref-shadowmapcube">ShadowMapCube</a></li>
<li><a href="shadowrenderer.html" data-page-link="ref-shadowrenderer">ShadowRenderer</a></li>
<li><a href="shadowtype.html" data-page-link="ref-shadowtype">ShadowType</a></li>
<li><a href="skybox.html" data-page-link="ref-skybox">SkyBox</a></li>
<li><a href="skybox6face.html" data-page-link="ref-skybox6face">SkyBox6Face</a></li>
<li><a href="skyboxloader.html" data-page-link="ref-skyboxloader">SkyBoxLoader</a></li>
<li><a href="skyboxmaterial.html" data-page-link="ref-skyboxmaterial">SkyboxMaterial</a></li>
<li><a href="stringutils.html" data-page-link="ref-stringutils">StringUtils</a></li>
<li><a href="textcachekey.html" data-page-link="ref-textcachekey">TextCacheKey</a></li>
<li><a href="texture.html" data-page-link="ref-texture">Texture</a></li>
<li><a href="textureslot.html" data-page-link="ref-textureslot">TextureSlot</a></li>
<li><a href="transform.html" data-page-link="ref-transform">Transform</a></li>
<li><a href="tripplebuffer.html" data-page-link="ref-tripplebuffer">TrippleBuffer</a></li>
<li><a href="uniform.html" data-page-link="ref-uniform">Uniform</a></li>
<li><a href="valuecontainer.html" data-page-link="ref-valuecontainer">ValueContainer</a></li>
<li><a href="vec2.html" data-page-link="ref-vec2">Vec2</a></li>
<li><a href="vec3.html" data-page-link="ref-vec3">Vec3</a></li>
<li><a href="vec4.html" data-page-link="ref-vec4">Vec4</a></li>
<li><a href="vertex.html" data-page-link="ref-vertex">Vertex</a></li>
<li><a href="vertexindex.html" data-page-link="ref-vertexindex">VertexIndex</a></li>
      </ul>
    </nav>

    <main class="content">
      <h1>Vertex</h1>
      <p class="muted">Declared in src/Mesh.h.</p>
      <p><strong>Header:</strong> <code>src/Mesh.h</code></p>

      <h2>Usage</h2>
      <p>Typical usage pattern (adjust to your pipeline):</p>
      <pre><code class="language-cpp">#include &quot;Mesh.h&quot;

Vertex instance;</code></pre>

      
      
      
      <h2>Member Functions</h2>
      <table class="ref-table">
        <thead><tr><th>Member</th><th>Description</th></tr></thead>
        <tbody>
<tr><td><code>Vertex&amp; Pos(const Math3D::Vec3&amp; pos){ }</code></td><td>Returns Vertex&amp;. Parameters: const Math3D::Vec3&amp; pos.</td></tr>
<tr><td><code>Vertex&amp; Pos(float x = 0, float y = 0, float z = 0){ }</code></td><td>Returns Vertex&amp;. Parameters: float x, float y, float z.</td></tr>
<tr><td><code>Vertex&amp; Norm(const Math3D::Vec3&amp; nml){ }</code></td><td>Returns Vertex&amp;. Parameters: const Math3D::Vec3&amp; nml.</td></tr>
<tr><td><code>Vertex&amp; Norm(float x = 0, float y = 0, float z = 0){ }</code></td><td>Returns Vertex&amp;. Parameters: float x, float y, float z.</td></tr>
<tr><td><code>Vertex&amp; UV(const Math3D::Vec2&amp; pos){ }</code></td><td>Returns Vertex&amp;. Parameters: const Math3D::Vec2&amp; pos.</td></tr>
<tr><td><code>Vertex&amp; UV(float u = 0, float v = 0){ }</code></td><td>Returns Vertex&amp;. Parameters: float u, float v.</td></tr>
<tr><td><code>Vertex&amp; Col(const Math3D::Vec4&amp; col){ }</code></td><td>Returns Vertex&amp;. Parameters: const Math3D::Vec4&amp; col.</td></tr>
<tr><td><code>Vertex&amp; Col(float r = 0, float g = 0, float b = 0, float a = 1){ }</code></td><td>Returns Vertex&amp;. Parameters: float r, float g, float b, float a.</td></tr>
<tr><td><code>bool operator==(const Vertex&amp; vtx) const { }</code></td><td>Performs the operation. Parameters: none.</td></tr>
<tr><td><code>bool operator!=(const Vertex&amp; vtx) const { }</code></td><td>Performs the operation. Parameters: none.</td></tr>
        </tbody>
      </table>

      
      <h2>Static Functions</h2>
      <table class="ref-table">
        <thead><tr><th>Member</th><th>Description</th></tr></thead>
        <tbody>
<tr><td><code>static Vertex Build(Math3D::Vec3 pos = Math3D::Vec3::zero(),Math3D::Vec4 color = Math3D::Vec4(1,1,1,1), Math3D::Vec3 normal = Math3D::Vec3::zero(), Math3D::Vec2 texcords = Math3D::Vec2(0,0)){ }</code></td><td>Returns Vertex. Parameters: Math3D::Vec3 pos, Math3D::Vec4 color, 1, 1, 1), Math3D::Vec3 normal, Math3D::Vec2 texcords, 0).</td></tr>
<tr><td><code>static Vertex Compose(std::vector&lt;float&gt;&amp; floats, int dataSize = VERTEX_DATA_WIDTH /* XYZRGBANNUV */){ }</code></td><td>Returns Vertex. Parameters: std::vector&lt;float&gt;&amp; floats, int dataSize.</td></tr>
<tr><td><code>static std::vector&lt;float&gt; Decompose(Vertex &amp;v){ }</code></td><td>Returns std::vector&lt;float&gt;. Parameters: Vertex &amp;v.</td></tr>
        </tbody>
      </table>

      
      <h2>Public Data</h2>
      <table class="ref-table">
        <thead><tr><th>Member</th><th>Description</th></tr></thead>
        <tbody>
<tr><td><code>Math3D::Vec3 Position</code></td><td>Data member of type Math3D::Vec3.</td></tr>
<tr><td><code>Math3D::Vec3 Normal</code></td><td>Data member of type Math3D::Vec3.</td></tr>
<tr><td><code>Math3D::Vec2 TexCoords</code></td><td>Data member of type Math3D::Vec2.</td></tr>
<tr><td><code>Math3D::Vec4 Color</code></td><td>Data member of type Math3D::Vec4.</td></tr>
<tr><td><code>static const int VERTEX_DATA_WIDTH = 12</code></td><td>Data member of type static const int.</td></tr>
        </tbody>
      </table>


      <h2>Public API</h2>
      <pre><code class="language-cpp">struct Vertex{
    Math3D::Vec3 Position;
    Math3D::Vec3 Normal;
    Math3D::Vec2 TexCoords;
    Math3D::Vec4 Color;

    static const int VERTEX_DATA_WIDTH = 12;

    Vertex&amp; Pos(const Math3D::Vec3&amp; pos){
        this-&gt;Position = pos;
        return *this;
    }

    Vertex&amp; Pos(float x = 0, float y = 0, float z = 0){
        return Pos(Math3D::Vec3(x,y,z));
    }

    Vertex&amp; Norm(const Math3D::Vec3&amp; nml){
        this-&gt;Normal = nml;
        return *this;
    }

    Vertex&amp; Norm(float x = 0, float y = 0, float z = 0){
        return Norm(Math3D::Vec3(x,y,z));
    }

    Vertex&amp; UV(const Math3D::Vec2&amp; pos){
        this-&gt;TexCoords = pos;
        return *this;
    }

    Vertex&amp; UV(float u = 0, float v = 0){
        return UV(Math3D::Vec2(u,v));
    }

    Vertex&amp; Col(const Math3D::Vec4&amp; col){
        this-&gt;Color = col;
        return *this;
    }

    Vertex&amp; Col(float r = 0, float g = 0, float b = 0, float a = 1){
        return Col(Math3D::Vec4(r,g,b,a));
    }


    static Vertex Build(Math3D::Vec3 pos = Math3D::Vec3::zero(),Math3D::Vec4 color = Math3D::Vec4(1,1,1,1), Math3D::Vec3 normal = Math3D::Vec3::zero(), Math3D::Vec2 texcords = Math3D::Vec2(0,0)){
        Vertex vtx;
        vtx.Position = pos;
        vtx.Normal = normal;
        vtx.Color = color;
        vtx.TexCoords = texcords;
        //Math3D::Random rand;
        //vtx.id = (rand.next&lt;uint16_t&gt;(INT16_MAX));
        return vtx;
    }

    static Vertex Compose(std::vector&lt;float&gt;&amp; floats, int dataSize = VERTEX_DATA_WIDTH /* XYZRGBANNUV */){
        std::vector&lt;float&gt; first12;
        for(int i = 0; i &lt; floats.size(); i++){
            if(i &lt; dataSize){
                first12.push_back(floats[i]);
            }else{
                break;
            }
        }


        Vertex vtx;
        if(first12.size() &gt;= 3){
            vtx.Position.x = first12[0];
            vtx.Position.y = first12[1];
            vtx.Position.z = first12[2];
        }

        if(first12.size() &gt;= 7){
            vtx.Color.x = first12[3];
            vtx.Color.y = first12[4];
            vtx.Color.z = first12[5];
            vtx.Color.w = first12[6];
        }

        if(first12.size() &gt;= 10){
            vtx.Normal.x = first12[7];
            vtx.Normal.y = first12[8];
            vtx.Normal.z = first12[9];
        }

        if(first12.size() &gt;= 12){
            vtx.TexCoords.x = first12[10];
            vtx.TexCoords.y = first12[11];
        }

        //Math3D::Random rand;
        //vtx.id = (rand.next&lt;uint16_t&gt;(INT16_MAX));

        return vtx;
    }

    static std::vector&lt;float&gt; Decompose(Vertex &amp;v){
        std::vector&lt;float&gt; vertexVector;
        /* XYZRGBANNUV */
        vertexVector.push_back(v.Position.x);
        vertexVector.push_back(v.Position.y);
        vertexVector.push_back(v.Position.z);
        vertexVector.push_back(v.Color.x);
        vertexVector.push_back(v.Color.y);
        vertexVector.push_back(v.Color.z);
        vertexVector.push_back(v.Color.w);
        vertexVector.push_back(v.Normal.x);
        vertexVector.push_back(v.Normal.y);
        vertexVector.push_back(v.Normal.z);
        vertexVector.push_back(v.TexCoords.x);
        vertexVector.push_back(v.TexCoords.y);

        return vertexVector;
    }

    bool operator==(const Vertex&amp; vtx) const {
        return
            Math3D::AreClose(Position.x, vtx.Position.x) &amp;&amp;
            Math3D::AreClose(Position.y, vtx.Position.y) &amp;&amp;
            Math3D::AreClose(Position.z, vtx.Position.z) &amp;&amp;

            Math3D::AreClose(Normal.x, vtx.Normal.x) &amp;&amp;
            Math3D::AreClose(Normal.y, vtx.Normal.y) &amp;&amp;
            Math3D::AreClose(Normal.z, vtx.Normal.z) &amp;&amp;

            Math3D::AreClose(TexCoords.x, vtx.TexCoords.x) &amp;&amp;
            Math3D::AreClose(TexCoords.y, vtx.TexCoords.y)  &amp;&amp;
            Math3D::AreClose(Color.x, vtx.Color.x) &amp;&amp;
            Math3D::AreClose(Color.y, vtx.Color.y)  &amp;&amp;
            Math3D::AreClose(Color.z, vtx.Color.z)  &amp;&amp;
            Math3D::AreClose(Color.w, vtx.Color.w);
    }

    bool operator!=(const Vertex&amp; vtx) const {
        return !(*this == vtx);
    }
};</code></pre>

      <h2>Full Class Layout</h2>
      <pre><code class="language-cpp">struct Vertex{
    Math3D::Vec3 Position;
    Math3D::Vec3 Normal;
    Math3D::Vec2 TexCoords;
    Math3D::Vec4 Color;

    static const int VERTEX_DATA_WIDTH = 12;

    Vertex&amp; Pos(const Math3D::Vec3&amp; pos){
        this-&gt;Position = pos;
        return *this;
    }

    Vertex&amp; Pos(float x = 0, float y = 0, float z = 0){
        return Pos(Math3D::Vec3(x,y,z));
    }

    Vertex&amp; Norm(const Math3D::Vec3&amp; nml){
        this-&gt;Normal = nml;
        return *this;
    }

    Vertex&amp; Norm(float x = 0, float y = 0, float z = 0){
        return Norm(Math3D::Vec3(x,y,z));
    }

    Vertex&amp; UV(const Math3D::Vec2&amp; pos){
        this-&gt;TexCoords = pos;
        return *this;
    }

    Vertex&amp; UV(float u = 0, float v = 0){
        return UV(Math3D::Vec2(u,v));
    }

    Vertex&amp; Col(const Math3D::Vec4&amp; col){
        this-&gt;Color = col;
        return *this;
    }

    Vertex&amp; Col(float r = 0, float g = 0, float b = 0, float a = 1){
        return Col(Math3D::Vec4(r,g,b,a));
    }


    static Vertex Build(Math3D::Vec3 pos = Math3D::Vec3::zero(),Math3D::Vec4 color = Math3D::Vec4(1,1,1,1), Math3D::Vec3 normal = Math3D::Vec3::zero(), Math3D::Vec2 texcords = Math3D::Vec2(0,0)){
        Vertex vtx;
        vtx.Position = pos;
        vtx.Normal = normal;
        vtx.Color = color;
        vtx.TexCoords = texcords;
        //Math3D::Random rand;
        //vtx.id = (rand.next&lt;uint16_t&gt;(INT16_MAX));
        return vtx;
    }

    static Vertex Compose(std::vector&lt;float&gt;&amp; floats, int dataSize = VERTEX_DATA_WIDTH /* XYZRGBANNUV */){
        std::vector&lt;float&gt; first12;
        for(int i = 0; i &lt; floats.size(); i++){
            if(i &lt; dataSize){
                first12.push_back(floats[i]);
            }else{
                break;
            }
        }


        Vertex vtx;
        if(first12.size() &gt;= 3){
            vtx.Position.x = first12[0];
            vtx.Position.y = first12[1];
            vtx.Position.z = first12[2];
        }

        if(first12.size() &gt;= 7){
            vtx.Color.x = first12[3];
            vtx.Color.y = first12[4];
            vtx.Color.z = first12[5];
            vtx.Color.w = first12[6];
        }

        if(first12.size() &gt;= 10){
            vtx.Normal.x = first12[7];
            vtx.Normal.y = first12[8];
            vtx.Normal.z = first12[9];
        }

        if(first12.size() &gt;= 12){
            vtx.TexCoords.x = first12[10];
            vtx.TexCoords.y = first12[11];
        }

        //Math3D::Random rand;
        //vtx.id = (rand.next&lt;uint16_t&gt;(INT16_MAX));

        return vtx;
    }

    static std::vector&lt;float&gt; Decompose(Vertex &amp;v){
        std::vector&lt;float&gt; vertexVector;
        /* XYZRGBANNUV */
        vertexVector.push_back(v.Position.x);
        vertexVector.push_back(v.Position.y);
        vertexVector.push_back(v.Position.z);
        vertexVector.push_back(v.Color.x);
        vertexVector.push_back(v.Color.y);
        vertexVector.push_back(v.Color.z);
        vertexVector.push_back(v.Color.w);
        vertexVector.push_back(v.Normal.x);
        vertexVector.push_back(v.Normal.y);
        vertexVector.push_back(v.Normal.z);
        vertexVector.push_back(v.TexCoords.x);
        vertexVector.push_back(v.TexCoords.y);

        return vertexVector;
    }

    bool operator==(const Vertex&amp; vtx) const {
        return
            Math3D::AreClose(Position.x, vtx.Position.x) &amp;&amp;
            Math3D::AreClose(Position.y, vtx.Position.y) &amp;&amp;
            Math3D::AreClose(Position.z, vtx.Position.z) &amp;&amp;

            Math3D::AreClose(Normal.x, vtx.Normal.x) &amp;&amp;
            Math3D::AreClose(Normal.y, vtx.Normal.y) &amp;&amp;
            Math3D::AreClose(Normal.z, vtx.Normal.z) &amp;&amp;

            Math3D::AreClose(TexCoords.x, vtx.TexCoords.x) &amp;&amp;
            Math3D::AreClose(TexCoords.y, vtx.TexCoords.y)  &amp;&amp;
            Math3D::AreClose(Color.x, vtx.Color.x) &amp;&amp;
            Math3D::AreClose(Color.y, vtx.Color.y)  &amp;&amp;
            Math3D::AreClose(Color.z, vtx.Color.z)  &amp;&amp;
            Math3D::AreClose(Color.w, vtx.Color.w);
    }

    bool operator!=(const Vertex&amp; vtx) const {
        return !(*this == vtx);
    }
};</code></pre>
    </main>

    <aside class="toc" id="toc"></aside>
  </div>

  <footer class="footer">RenderingThing Docs - Local build</footer>
  <script src="../app.js"></script>
</body>
</html>
