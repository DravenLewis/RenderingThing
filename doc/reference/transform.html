<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RenderingThing Docs - Transform</title>
  <link rel="stylesheet" href="../style.css" />
</head>
<body data-page="ref-transform">
  <header class="topbar">
    <div class="brand">
      <div class="logo">RT</div>
      <div>RenderingThing Docs</div>
      <span class="badge">Local</span>
    </div>
    <div class="search">
      <input type="search" placeholder="Search docs (local)" />
    </div>
    <button class="nav-toggle" aria-label="Toggle navigation">Menu</button>
  </header>

  <div class="layout">
    <nav class="sidenav">

      <h3>Documentation</h3>
      <ul>
        <li><a href="../index.html" data-page-link="overview">Overview</a></li>
        <li><a href="../getting-started.html" data-page-link="getting-started">Getting Started</a></li>
        <li><a href="../samples.html" data-page-link="samples">Samples</a></li>
        <li><a href="../architecture.html" data-page-link="architecture">Architecture</a></li>
        <li><a href="../graphics.html" data-page-link="graphics">Graphics</a></li>
        <li><a href="index.html" data-page-link="reference">Reference</a></li>
      </ul>
      <h3>Reference</h3>
      <ul>
<li><a href="asset.html" data-page-link="ref-asset">Asset</a></li>
<li><a href="assetmanager.html" data-page-link="ref-assetmanager">AssetManager</a></li>
<li><a href="bufferedimage.html" data-page-link="ref-bufferedimage">BufferedImage</a></li>
<li><a href="camera.html" data-page-link="ref-camera">Camera</a></li>
<li><a href="camerasettings.html" data-page-link="ref-camerasettings">CameraSettings</a></li>
<li><a href="color.html" data-page-link="ref-color">Color</a></li>
<li><a href="colormaterial.html" data-page-link="ref-colormaterial">ColorMaterial</a></li>
<li><a href="cubemap.html" data-page-link="ref-cubemap">CubeMap</a></li>
<li><a href="cubemapslot.html" data-page-link="ref-cubemapslot">CubeMapSlot</a></li>
<li><a href="cubematerialdefinition.html" data-page-link="ref-cubematerialdefinition">CubeMaterialDefinition</a></li>
<li><a href="depthguard.html" data-page-link="ref-depthguard">DepthGuard</a></li>
<li><a href="display.html" data-page-link="ref-display">Display</a></li>
<li><a href="displaymode.html" data-page-link="ref-displaymode">DisplayMode</a></li>
<li><a href="file.html" data-page-link="ref-file">File</a></li>
<li><a href="fileblob.html" data-page-link="ref-fileblob">FileBlob</a></li>
<li><a href="filereader.html" data-page-link="ref-filereader">FileReader</a></li>
<li><a href="filewriter.html" data-page-link="ref-filewriter">FileWriter</a></li>
<li><a href="firstpersoncontroller.html" data-page-link="ref-firstpersoncontroller">FirstPersonController</a></li>
<li><a href="flatcolormaterial.html" data-page-link="ref-flatcolormaterial">FlatColorMaterial</a></li>
<li><a href="flatimagematerial.html" data-page-link="ref-flatimagematerial">FlatImageMaterial</a></li>
<li><a href="font.html" data-page-link="ref-font">Font</a></li>
<li><a href="fontcharacter.html" data-page-link="ref-fontcharacter">FontCharacter</a></li>
<li><a href="framebuffer.html" data-page-link="ref-framebuffer">FrameBuffer</a></li>
<li><a href="framebufferchain.html" data-page-link="ref-framebufferchain">FrameBufferChain</a></li>
<li><a href="freetypefont.html" data-page-link="ref-freetypefont">FreeTypeFont</a></li>
<li><a href="glversioninfo.html" data-page-link="ref-glversioninfo">GLVersionInfo</a></li>
<li><a href="graphics2d.html" data-page-link="ref-graphics2d">Graphics2D</a></li>
<li><a href="graphicscontext.html" data-page-link="ref-graphicscontext">GraphicsContext</a></li>
<li><a href="grayscaleeffect.html" data-page-link="ref-grayscaleeffect">GrayscaleEffect</a></li>
<li><a href="idrawable.html" data-page-link="ref-idrawable">IDrawable</a></li>
<li><a href="ieventhandler.html" data-page-link="ref-ieventhandler">IEventHandler</a></li>
<li><a href="image.html" data-page-link="ref-image">Image</a></li>
<li><a href="imagematerial.html" data-page-link="ref-imagematerial">ImageMaterial</a></li>
<li><a href="imaterialproperty.html" data-page-link="ref-imaterialproperty">IMaterialProperty</a></li>
<li><a href="inputinformation.html" data-page-link="ref-inputinformation">InputInformation</a></li>
<li><a href="inputmanager.html" data-page-link="ref-inputmanager">InputManager</a></li>
<li><a href="light.html" data-page-link="ref-light">Light</a></li>
<li><a href="lightmanager.html" data-page-link="ref-lightmanager">LightManager</a></li>
<li><a href="lighttype.html" data-page-link="ref-lighttype">LightType</a></li>
<li><a href="lightuniformuploader.html" data-page-link="ref-lightuniformuploader">LightUniformUploader</a></li>
<li><a href="lineending.html" data-page-link="ref-lineending">LineEnding</a></li>
<li><a href="litcolormaterial.html" data-page-link="ref-litcolormaterial">LitColorMaterial</a></li>
<li><a href="litimagematerial.html" data-page-link="ref-litimagematerial">LitImageMaterial</a></li>
<li><a href="logbot.html" data-page-link="ref-logbot">Logbot</a></li>
<li><a href="logtype.html" data-page-link="ref-logtype">LogType</a></li>
<li><a href="mat4.html" data-page-link="ref-mat4">Mat4</a></li>
<li><a href="material.html" data-page-link="ref-material">Material</a></li>
<li><a href="materialproperty.html" data-page-link="ref-materialproperty">MaterialProperty</a></li>
<li><a href="mesh.html" data-page-link="ref-mesh">Mesh</a></li>
<li><a href="model.html" data-page-link="ref-model">Model</a></li>
<li><a href="modelpart.html" data-page-link="ref-modelpart">ModelPart</a></li>
<li><a href="modelpartfactory.html" data-page-link="ref-modelpartfactory">ModelPartFactory</a></li>
<li><a href="modelpartprefabs.html" data-page-link="ref-modelpartprefabs">ModelPartPrefabs</a></li>
<li><a href="modelprefabs.html" data-page-link="ref-modelprefabs">ModelPrefabs</a></li>
<li><a href="mouselockmode.html" data-page-link="ref-mouselockmode">MouseLockMode</a></li>
<li><a href="nullable.html" data-page-link="ref-nullable">Nullable</a></li>
<li><a href="objdata.html" data-page-link="ref-objdata">OBJData</a></li>
<li><a href="objloader.html" data-page-link="ref-objloader">OBJLoader</a></li>
<li><a href="pbrmaterial.html" data-page-link="ref-pbrmaterial">PBRMaterial</a></li>
<li><a href="postprocessingeffect.html" data-page-link="ref-postprocessingeffect">PostProcessingEffect</a></li>
<li><a href="quat.html" data-page-link="ref-quat">Quat</a></li>
<li><a href="random.html" data-page-link="ref-random">Random</a></li>
<li><a href="rect.html" data-page-link="ref-rect">Rect</a></li>
<li><a href="renderwindow.html" data-page-link="ref-renderwindow">RenderWindow</a></li>
<li><a href="screen.html" data-page-link="ref-screen">Screen</a></li>
<li><a href="shaderbundle.html" data-page-link="ref-shaderbundle">ShaderBundle</a></li>
<li><a href="shadercache.html" data-page-link="ref-shadercache">ShaderCache</a></li>
<li><a href="shaderprogram.html" data-page-link="ref-shaderprogram">ShaderProgram</a></li>
<li><a href="shadowlightdata.html" data-page-link="ref-shadowlightdata">ShadowLightData</a></li>
<li><a href="shadowmap2d.html" data-page-link="ref-shadowmap2d">ShadowMap2D</a></li>
<li><a href="shadowmapcube.html" data-page-link="ref-shadowmapcube">ShadowMapCube</a></li>
<li><a href="shadowrenderer.html" data-page-link="ref-shadowrenderer">ShadowRenderer</a></li>
<li><a href="shadowtype.html" data-page-link="ref-shadowtype">ShadowType</a></li>
<li><a href="skybox.html" data-page-link="ref-skybox">SkyBox</a></li>
<li><a href="skybox6face.html" data-page-link="ref-skybox6face">SkyBox6Face</a></li>
<li><a href="skyboxloader.html" data-page-link="ref-skyboxloader">SkyBoxLoader</a></li>
<li><a href="skyboxmaterial.html" data-page-link="ref-skyboxmaterial">SkyboxMaterial</a></li>
<li><a href="stringutils.html" data-page-link="ref-stringutils">StringUtils</a></li>
<li><a href="textcachekey.html" data-page-link="ref-textcachekey">TextCacheKey</a></li>
<li><a href="texture.html" data-page-link="ref-texture">Texture</a></li>
<li><a href="textureslot.html" data-page-link="ref-textureslot">TextureSlot</a></li>
<li><a href="transform.html" data-page-link="ref-transform">Transform</a></li>
<li><a href="tripplebuffer.html" data-page-link="ref-tripplebuffer">TrippleBuffer</a></li>
<li><a href="uniform.html" data-page-link="ref-uniform">Uniform</a></li>
<li><a href="valuecontainer.html" data-page-link="ref-valuecontainer">ValueContainer</a></li>
<li><a href="vec2.html" data-page-link="ref-vec2">Vec2</a></li>
<li><a href="vec3.html" data-page-link="ref-vec3">Vec3</a></li>
<li><a href="vec4.html" data-page-link="ref-vec4">Vec4</a></li>
<li><a href="vertex.html" data-page-link="ref-vertex">Vertex</a></li>
<li><a href="vertexindex.html" data-page-link="ref-vertexindex">VertexIndex</a></li>
      </ul>
    </nav>

    <main class="content">
      <h1>Transform</h1>
      <p class="muted">--- Robust Transform ---</p>
      <p><strong>Header:</strong> <code>src/Math.h</code></p>

      <h2>Usage</h2>
      <p>Typical usage pattern (adjust to your pipeline):</p>
      <pre><code class="language-cpp">#include &quot;Math.h&quot;

Transform instance;</code></pre>

      
      
      <h2>Constructors / Destructors</h2>
      <table class="ref-table">
        <thead><tr><th>Member</th><th>Description</th></tr></thead>
        <tbody>
<tr><td><code>Transform(Vec3 pos = Vec3::zero(), Quat rot = Quat(), Vec3 scl = Vec3::one())
            : position(pos), rotation(rot), scale(scl) {}

        
        Mat4 toMat4() const {
            
            glm::mat4 m = glm::mat4(1.0f)</code></td><td>Constructs the object.</td></tr>
<tr><td><code>return Transform((Vec3)trans, rot, (Vec3)scaleVec)</code></td><td>Constructs the object.</td></tr>
        </tbody>
      </table>

      
      <h2>Member Functions</h2>
      <table class="ref-table">
        <thead><tr><th>Member</th><th>Description</th></tr></thead>
        <tbody>
<tr><td><code>m = glm::translate(m, (glm::vec3)position)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>m *= glm::toMat4((glm::quat)rotation)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>m = glm::scale(m, (glm::vec3)scale)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>return Mat4(m)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}

        
        
        
        Mat4 operator*(const Transform&amp; child) const {
            return this-&gt;toMat4() * child.toMat4()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}

        
        Vec3 forward() const { return rotation * Vec3(0, 0, 1)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}
        Vec3 right()   const { return rotation * Vec3(1, 0, 0)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}
        Vec3 up()      const { return rotation * Vec3(0, 1, 0)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}

        
        void setRotation(float x, float y, float z) {
            rotation = Quat::FromEuler(Vec3(x, y, z))</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}

        void setRotation(const Vec3&amp; eulerAngles) {
            rotation = Quat::FromEuler(eulerAngles)</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}

        

        
        void setPosition(const Vec3&amp; p) { position = p</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}
        void setPosition(float x, float y, float z) { position = Vec3(x,y,z)</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}
        void translate(const Vec3&amp; delta) { position += delta</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}
        void translate(float x = 0, float y = 0, float z = 0) { position += Vec3(x,y,z)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}
        void setX(float x) { position.x = x</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}
        void setY(float y) { position.y = y</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}
        void setZ(float z) { position.z = z</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}

        
        void setScale(const Vec3&amp; s) { scale = s</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}
        void setUniformScale(float s) { scale = Vec3(s, s, s)</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}
        void setScale(float x = 1.0f, float y = 1.0f, float z = 1.0f) {scale = Vec3(x, y, z)</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}

        
        void rotateAxisAngle(const Vec3&amp; axis, float angleDeg, bool localSpace = true) {
            Quat q = Quat::AngleAxis(angleDeg, axis)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>if(localSpace){
                rotation = rotation * q</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}

            rotation = rotation.normalize()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}

        
        void lookAt(const Vec3&amp; target, const Vec3&amp; worldUp = Vec3(0,1,0)) {
            Vec3 dir = target - position</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>float lengthSquared = dir.length() * dir.length()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>if (lengthSquared &lt; 1e-8f) return</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>Vec3 f = dir.normalize()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>Vec3 up = worldUp.normalize()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>if (fabs(Vec3::dot(f, up)) &gt; 0.999f) {
                up = Vec3::cross(f, Vec3::right()).normalize()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>float upLengthSquared = up.length() * up.length()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>if (upLengthSquared &lt; 1e-6f)
                    up = Vec3::cross(f, Vec3::forward()).normalize()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}

            Vec3 r = Vec3::cross(up,f).normalize()</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>Vec3 u = Vec3::cross(f, r)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>rotMat[0] = (glm::vec3) r</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>rotMat[1] = (glm::vec3) u</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>rotMat[2] = (glm::vec3) f</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>rotation = Quat::FromMat3(rotMat)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>glm::vec3 trans = glm::vec3(m[3])</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>glm::vec3 col0 = glm::vec3(m[0])</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>glm::vec3 col1 = glm::vec3(m[1])</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>glm::vec3 col2 = glm::vec3(m[2])</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>float sx = glm::length(col0)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>float sy = glm::length(col1)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>float sz = glm::length(col2)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>glm::vec3 scaleVec(sx &gt; 1e-8f ? sx : 0.0f,
                               sy &gt; 1e-8f ? sy : 0.0f,
                               sz &gt; 1e-8f ? sz : 0.0f)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>if (sx &gt; 1e-8f) rotMat[0] = col0 / sx</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>else rotMat[0] = glm::vec3(1,0,0)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>if (sy &gt; 1e-8f) rotMat[1] = col1 / sy</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>else rotMat[1] = glm::vec3(0,1,0)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>if (sz &gt; 1e-8f) rotMat[2] = col2 / sz</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>else rotMat[2] = glm::vec3(0,0,1)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>Quat rot = (Quat)glm::quat_cast(rotMat)</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}

        
        void setFromMat4(const Mat4&amp; m) {
            *this = Transform::fromMat4(m)</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>}

        void reset(){
            this-&gt;setPosition(Math3D::Vec3(0,0))</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>this-&gt;setScale(Math3D::Vec3(1,1,1))</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>this-&gt;setRotation(0.0f,0.0f,0.0f)</code></td><td>Sets the requested value.</td></tr>
<tr><td><code>return Vec3(p.x, p.y, p.z)</code></td><td>Performs the operation described by the name.</td></tr>
        </tbody>
      </table>

      
      <h2>Static Functions</h2>
      <table class="ref-table">
        <thead><tr><th>Member</th><th>Description</th></tr></thead>
        <tbody>
<tr><td><code>}

        
        static Transform fromMat4(const Mat4&amp; m_in) {
            
            glm::mat4 m = (glm::mat4)m_in</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}

        
        static Vec3 transformPoint(const Mat4&amp; parentMat, const Vec3&amp; localPoint) {
            glm::vec4 p = (glm::mat4)parentMat * glm::vec4((glm::vec3)localPoint, 1.0f)</code></td><td>Performs the operation described by the name.</td></tr>
        </tbody>
      </table>

      
      <h2>Public Data</h2>
      <table class="ref-table">
        <thead><tr><th>Member</th><th>Description</th></tr></thead>
        <tbody>
<tr><td><code>Vec3 position</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>Quat rotation</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>Vec3 scale</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}else{
                rotation = q * rotation</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>glm::mat3 rotMat</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>glm::mat3 rotMat</code></td><td>Performs the operation described by the name.</td></tr>
<tr><td><code>}</code></td><td>Performs the operation described by the name.</td></tr>
        </tbody>
      </table>


      <h2>Public API</h2>
      <pre><code class="language-cpp">struct Transform {
        Vec3 position;
        Quat rotation;
        Vec3 scale;

        Transform(Vec3 pos = Vec3::zero(), Quat rot = Quat(), Vec3 scl = Vec3::one())
            : position(pos), rotation(rot), scale(scl) {}

        // 1. Convert to Matrix (The Source of Truth)
        Mat4 toMat4() const {
            // Translate * Rotate * Scale
            glm::mat4 m = glm::mat4(1.0f);
            m = glm::translate(m, (glm::vec3)position);
            m *= glm::toMat4((glm::quat)rotation);
            m = glm::scale(m, (glm::vec3)scale);
            return Mat4(m);
        }

        // 2. The Robust Combination
        // Instead of returning a &#x27;Transform&#x27;, we return a &#x27;Mat4&#x27;.
        // This preserves any skewing caused by non-uniform parent scaling.
        Mat4 operator*(const Transform&amp; child) const {
            return this-&gt;toMat4() * child.toMat4();
        }

        // 3. Directions (Local Space)
        Vec3 forward() const { return rotation * Vec3(0, 0, 1); }
        Vec3 right()   const { return rotation * Vec3(1, 0, 0); }
        Vec3 up()      const { return rotation * Vec3(0, 1, 0); }

        // 4. Helper to set rotation from Euler easily
        void setRotation(float x, float y, float z) {
            rotation = Quat::FromEuler(Vec3(x, y, z));
        }

        void setRotation(const Vec3&amp; eulerAngles) {
            rotation = Quat::FromEuler(eulerAngles);
        }

        // ===== ADDED HELPERS (minimal, non-invasive) =====

        // Position setters / movers
        void setPosition(const Vec3&amp; p) { position = p; }
        void setPosition(float x, float y, float z) { position = Vec3(x,y,z); }
        void translate(const Vec3&amp; delta) { position += delta; }
        void translate(float x = 0, float y = 0, float z = 0) { position += Vec3(x,y,z); }
        void setX(float x) { position.x = x; }
        void setY(float y) { position.y = y; }
        void setZ(float z) { position.z = z; }

        // Scale setters
        void setScale(const Vec3&amp; s) { scale = s; }
        void setUniformScale(float s) { scale = Vec3(s, s, s); }
        void setScale(float x = 1.0f, float y = 1.0f, float z = 1.0f) {scale = Vec3(x, y, z); }

        // Rotate around an arbitrary axis (angle in radians)
        void rotateAxisAngle(const Vec3&amp; axis, float angleDeg, bool localSpace = true) {
            Quat q = Quat::AngleAxis(angleDeg, axis);

            if(localSpace){
                rotation = rotation * q;
            }else{
                rotation = q * rotation;
            }

            rotation = rotation.normalize();
        }

        // Set rotation from forward and up (construct a rotation where local +Z points to forward)
        void lookAt(const Vec3&amp; target, const Vec3&amp; worldUp = Vec3(0,1,0)) {
            Vec3 dir = target - position;
            // avoid degenerate case
            float lengthSquared = dir.length() * dir.length();
            if (lengthSquared &lt; 1e-8f) return;

            Vec3 f = dir.normalize();
            Vec3 up = worldUp.normalize();

            // Handle near-parallel forward/up
            if (fabs(Vec3::dot(f, up)) &gt; 0.999f) {
                up = Vec3::cross(f, Vec3::right()).normalize();
                float upLengthSquared = up.length() * up.length();
                if (upLengthSquared &lt; 1e-6f)
                    up = Vec3::cross(f, Vec3::forward()).normalize();
            }

            Vec3 r = Vec3::cross(up,f).normalize(); // right
            Vec3 u = Vec3::cross(f, r);                   // recomputed up (orthonormal)

            // Build rotation matrix where columns are (right, up, forward)
            glm::mat3 rotMat;
            rotMat[0] = (glm::vec3) r; // column 0
            rotMat[1] = (glm::vec3) u; // column 1
            rotMat[2] = (glm::vec3) f; // column 2

            rotation = Quat::FromMat3(rotMat);
        }

        // Build a transform from a Mat4 (decomposes translation / rotation / scale)
        static Transform fromMat4(const Mat4&amp; m_in) {
            // assumes Mat4 can be casted to glm::mat4 via constructor like Mat4(glm::mat4)
            glm::mat4 m = (glm::mat4)m_in; // adjust cast if your Mat4 type differs

            // Extract translation
            glm::vec3 trans = glm::vec3(m[3]); // column-major: 4th column is translation

            // Extract scale from column lengths (note: this loses shear)
            glm::vec3 col0 = glm::vec3(m[0]);
            glm::vec3 col1 = glm::vec3(m[1]);
            glm::vec3 col2 = glm::vec3(m[2]);
            float sx = glm::length(col0);
            float sy = glm::length(col1);
            float sz = glm::length(col2);

            // Avoid division by zero
            glm::vec3 scaleVec(sx &gt; 1e-8f ? sx : 0.0f,
                               sy &gt; 1e-8f ? sy : 0.0f,
                               sz &gt; 1e-8f ? sz : 0.0f);

            // Normalize rotation matrix columns to remove scale
            glm::mat3 rotMat;
            if (sx &gt; 1e-8f) rotMat[0] = col0 / sx; else rotMat[0] = glm::vec3(1,0,0);
            if (sy &gt; 1e-8f) rotMat[1] = col1 / sy; else rotMat[1] = glm::vec3(0,1,0);
            if (sz &gt; 1e-8f) rotMat[2] = col2 / sz; else rotMat[2] = glm::vec3(0,0,1);

            Quat rot = (Quat)glm::quat_cast(rotMat);

            return Transform((Vec3)trans, rot, (Vec3)scaleVec);
        }

        // Convenience: set transform from mat directly
        void setFromMat4(const Mat4&amp; m) {
            *this = Transform::fromMat4(m);
        }

        void reset(){
            this-&gt;setPosition(Math3D::Vec3(0,0));
            this-&gt;setScale(Math3D::Vec3(1,1,1));
            this-&gt;setRotation(0.0f,0.0f,0.0f);
        }

        // Quick utility: returns world-space position after applying a parent transform matrix
        static Vec3 transformPoint(const Mat4&amp; parentMat, const Vec3&amp; localPoint) {
            glm::vec4 p = (glm::mat4)parentMat * glm::vec4((glm::vec3)localPoint, 1.0f);
            return Vec3(p.x, p.y, p.z);
        }
    };</code></pre>

      <h2>Full Class Layout</h2>
      <pre><code class="language-cpp">struct Transform {
        Vec3 position;
        Quat rotation;
        Vec3 scale;

        Transform(Vec3 pos = Vec3::zero(), Quat rot = Quat(), Vec3 scl = Vec3::one())
            : position(pos), rotation(rot), scale(scl) {}

        // 1. Convert to Matrix (The Source of Truth)
        Mat4 toMat4() const {
            // Translate * Rotate * Scale
            glm::mat4 m = glm::mat4(1.0f);
            m = glm::translate(m, (glm::vec3)position);
            m *= glm::toMat4((glm::quat)rotation);
            m = glm::scale(m, (glm::vec3)scale);
            return Mat4(m);
        }

        // 2. The Robust Combination
        // Instead of returning a &#x27;Transform&#x27;, we return a &#x27;Mat4&#x27;.
        // This preserves any skewing caused by non-uniform parent scaling.
        Mat4 operator*(const Transform&amp; child) const {
            return this-&gt;toMat4() * child.toMat4();
        }

        // 3. Directions (Local Space)
        Vec3 forward() const { return rotation * Vec3(0, 0, 1); }
        Vec3 right()   const { return rotation * Vec3(1, 0, 0); }
        Vec3 up()      const { return rotation * Vec3(0, 1, 0); }

        // 4. Helper to set rotation from Euler easily
        void setRotation(float x, float y, float z) {
            rotation = Quat::FromEuler(Vec3(x, y, z));
        }

        void setRotation(const Vec3&amp; eulerAngles) {
            rotation = Quat::FromEuler(eulerAngles);
        }

        // ===== ADDED HELPERS (minimal, non-invasive) =====

        // Position setters / movers
        void setPosition(const Vec3&amp; p) { position = p; }
        void setPosition(float x, float y, float z) { position = Vec3(x,y,z); }
        void translate(const Vec3&amp; delta) { position += delta; }
        void translate(float x = 0, float y = 0, float z = 0) { position += Vec3(x,y,z); }
        void setX(float x) { position.x = x; }
        void setY(float y) { position.y = y; }
        void setZ(float z) { position.z = z; }

        // Scale setters
        void setScale(const Vec3&amp; s) { scale = s; }
        void setUniformScale(float s) { scale = Vec3(s, s, s); }
        void setScale(float x = 1.0f, float y = 1.0f, float z = 1.0f) {scale = Vec3(x, y, z); }

        // Rotate around an arbitrary axis (angle in radians)
        void rotateAxisAngle(const Vec3&amp; axis, float angleDeg, bool localSpace = true) {
            Quat q = Quat::AngleAxis(angleDeg, axis);

            if(localSpace){
                rotation = rotation * q;
            }else{
                rotation = q * rotation;
            }

            rotation = rotation.normalize();
        }

        // Set rotation from forward and up (construct a rotation where local +Z points to forward)
        void lookAt(const Vec3&amp; target, const Vec3&amp; worldUp = Vec3(0,1,0)) {
            Vec3 dir = target - position;
            // avoid degenerate case
            float lengthSquared = dir.length() * dir.length();
            if (lengthSquared &lt; 1e-8f) return;

            Vec3 f = dir.normalize();
            Vec3 up = worldUp.normalize();

            // Handle near-parallel forward/up
            if (fabs(Vec3::dot(f, up)) &gt; 0.999f) {
                up = Vec3::cross(f, Vec3::right()).normalize();
                float upLengthSquared = up.length() * up.length();
                if (upLengthSquared &lt; 1e-6f)
                    up = Vec3::cross(f, Vec3::forward()).normalize();
            }

            Vec3 r = Vec3::cross(up,f).normalize(); // right
            Vec3 u = Vec3::cross(f, r);                   // recomputed up (orthonormal)

            // Build rotation matrix where columns are (right, up, forward)
            glm::mat3 rotMat;
            rotMat[0] = (glm::vec3) r; // column 0
            rotMat[1] = (glm::vec3) u; // column 1
            rotMat[2] = (glm::vec3) f; // column 2

            rotation = Quat::FromMat3(rotMat);
        }

        // Build a transform from a Mat4 (decomposes translation / rotation / scale)
        static Transform fromMat4(const Mat4&amp; m_in) {
            // assumes Mat4 can be casted to glm::mat4 via constructor like Mat4(glm::mat4)
            glm::mat4 m = (glm::mat4)m_in; // adjust cast if your Mat4 type differs

            // Extract translation
            glm::vec3 trans = glm::vec3(m[3]); // column-major: 4th column is translation

            // Extract scale from column lengths (note: this loses shear)
            glm::vec3 col0 = glm::vec3(m[0]);
            glm::vec3 col1 = glm::vec3(m[1]);
            glm::vec3 col2 = glm::vec3(m[2]);
            float sx = glm::length(col0);
            float sy = glm::length(col1);
            float sz = glm::length(col2);

            // Avoid division by zero
            glm::vec3 scaleVec(sx &gt; 1e-8f ? sx : 0.0f,
                               sy &gt; 1e-8f ? sy : 0.0f,
                               sz &gt; 1e-8f ? sz : 0.0f);

            // Normalize rotation matrix columns to remove scale
            glm::mat3 rotMat;
            if (sx &gt; 1e-8f) rotMat[0] = col0 / sx; else rotMat[0] = glm::vec3(1,0,0);
            if (sy &gt; 1e-8f) rotMat[1] = col1 / sy; else rotMat[1] = glm::vec3(0,1,0);
            if (sz &gt; 1e-8f) rotMat[2] = col2 / sz; else rotMat[2] = glm::vec3(0,0,1);

            Quat rot = (Quat)glm::quat_cast(rotMat);

            return Transform((Vec3)trans, rot, (Vec3)scaleVec);
        }

        // Convenience: set transform from mat directly
        void setFromMat4(const Mat4&amp; m) {
            *this = Transform::fromMat4(m);
        }

        void reset(){
            this-&gt;setPosition(Math3D::Vec3(0,0));
            this-&gt;setScale(Math3D::Vec3(1,1,1));
            this-&gt;setRotation(0.0f,0.0f,0.0f);
        }

        // Quick utility: returns world-space position after applying a parent transform matrix
        static Vec3 transformPoint(const Mat4&amp; parentMat, const Vec3&amp; localPoint) {
            glm::vec4 p = (glm::mat4)parentMat * glm::vec4((glm::vec3)localPoint, 1.0f);
            return Vec3(p.x, p.y, p.z);
        }
    };</code></pre>
    </main>

    <aside class="toc" id="toc"></aside>
  </div>

  <footer class="footer">RenderingThing Docs - Local build</footer>
  <script src="../app.js"></script>
</body>
</html>
